# Interface Delegation

인터페이스의 구현을 필드 혹은 프로퍼티에 위임하는 코드를 자동으로 생성하는 C# 소스 제네레이터입니다.

## 빌드하기

다음과 같은 순서로 명령을 수행하여 NuGet 패키지를 생성할 수 있습니다.

```shell
dotnet build -c Release
dotnet pack ./InterfaceDelegation/InterfaceDelegation.csproj -c Release
```

`./InterfaceDelegation/bin/Release/` 폴더에 `nupkg` 확장자를 가지는 패키지가 생성됩니다.

## 사용법

### `ImplementationOf` 어트리뷰트를 사용하여 인터페이스 위임하기

`ImplementationOf` 어트리뷰트를 필드 혹은 프로퍼티에 적용하면 어트리뷰트에 지정한 인터페이스를 구현하는 코드를 생성합니다. 어트리뷰트를 사용하는 타입은 `partial`로 선언되어야 합니다.

> :warning: 값 타입의 프로퍼티에는 적용할 수 없습니다.

```csharp
using Macaron.InterfaceDelegation;

public interface IFoo
{
    void Bar();
}

// 인터페이스에 대한 코드를 구현한 대상이 해당 인터페이스를 구현할 필요는 없습니다.
public class FooImpl
{
    public void Bar() { }
}

public partial class Qux : IFoo
{
    [ImplementationOf(typeof(IFoo))]
    private FooImpl _impl = new();
}
```

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Qux
{
    #region global::IFoo
    public void Bar()
        => _impl.Bar();
    #endregion
}
```

> :warning: 메서드, 프로퍼티, 인덱서만 적용됩니다. 이벤트는 적용되지 않습니다.  

`FooImpl`이 실제로 `IFoo`를 구현했는지 여부는 고려하지 않습니다. 생성된 코드에서 대상을 호출할 수 없다면 컴파일 오류가 발생합니다.

#### 특정 멤버를 직접 구현하기

이미 구현된 항목은 코드를 생성하지 않습니다.

```csharp
using Macaron.InterfaceDelegation;

public interface IFoo
{
    void Bar();
    
    void Qux();
    
    void Quux();
}

public class FooImpl : IFoo
{
    public void Bar() { }
    
    public void Qux() { }
    
    // 인터페이스를 구현했다면 명시적 구현도 호출 대상이 됩니다.
    void IFoo.Quux() { }
}

public partial class Qux : IFoo
{
    [ImplementationOf(typeof(IFoo))]
    private FooImpl _impl = new();
    
    // Bar는 구현되었기 때문에 코드를 생성하지 않습니다.
    public void Bar() { }
}
```

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Qux
{
    #region global::IFoo
    void global::IFoo.Qux()
    {
        __Qux(ref _impl);

        #region Local Functions
        static void __Qux<__T>(ref __T __impl) where __T : global::IFoo => __impl.Qux();
        #endregion
    }

    public void Quux()
    {
        __Quux(ref _impl);

        #region Local Functions
        static void __Quux<__T>(ref __T __impl) where __T : global::IFoo => __impl.Quux();
        #endregion
    }
    #endregion
}
```

#### 구현 모드 지정하기

`ImplementationOf`는 `Implicit`, `Explicit` 두 개의 구현 모드를 가지고 있습니다. `ImplementationOf` 생성자의 두 번째 매개변수에 모드를 지정할 수 있습니다.

- `Implicit`: 인터페이스의 멤버를 `public` 접근 제한자를 사용하여 구현합니다. 타입이 명시적 혹은 암시적으로 해당 멤버를 구현했다면 아무것도 하지 않습니다.
- `Explicit`: 인터페이스의 멤버를 명시적으로 구현합니다. 타입이 명시적으로 해당 멤버를 구현했다면 아무것도 하지 않습니다. 암시적 구현은 고려하지 않습니다.

구현하려고 하는 멤버의 이름이 멤버가 선언된 타입과 동일한 경우 `Implicit` 모드를 지정해도 해당 멤버는 `Explicit` 모드를 사용합니다.

### `Lift` 어트리뷰를 사용하여 필드 혹은 프로퍼티의 멤버를 선언된 타입에 위임하기

`Lift` 어트리뷰트를 필드나 프로퍼티에 적용하여 지정한 대상의 멤버를 위임하는 코드를 생성할 수 있습니다. 대상이 되는 멤버는 `public` 혹은 `internal` 접근 제한자를 가지는 프로퍼티 혹은 메서드입니다. `ImplementationOf`와 다르게 인덱서는 위임 대상이 아닙니다. `ImplementationOf`는 값 타입 프로퍼티에 적용할 수 없지만 `Lift`는 가능합니다.

```csharp
using Macaron.InterfaceDelegation;

public class Foo
{
    public void Bar() { }
    
    internal int Quux => 42;
}

public partial class Qux
{
    [Lift]
    private Foo _foo = new();
}
```

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Qux
{
    #region global::Foo
    public void Bar()
        => _foo.Bar();

    internal int Quux
    {
        get => _foo.Quux;
    }
    #endregion
}
```

`ImplementationOf`와 동일하게 이미 동일한 시그니처의 멤버가 존재한다면 해당 멤버는 위임하지 않습니다. 다만 자동 생성되는 코드나 타입 이름과 동일한 멤버가 생성되는 것은 고려하지 않기 때문에 주의가 필요합니다. 멤버 이름 충돌은 옵션을 지정하여 해결할 수 있습니다.

#### `Lift`에 옵션을 지정하여 위임할 멤버를 선택하기

`Lift` 어트리뷰트는 세 개의 옵션을 지정할 수 있습니다. 모든 옵션은 문자열 목록입니다.

- `filter`: 지정한 이름의 멤버만 위임 대상에 포함합니다. 값을 지정하지 않으면 모든 멤버가 대상이 됩니다.
- `remove`: `filter`가 적용된 위임 대상 목록에서 지정한 이름의 멤버를 제외합니다.
- `rename`: 남은 위임 대상에 대해서 `키:값` 형태의 문자열을 사용하여 위임할 이름을 변경합니다.

```csharp
using Macaron.InterfaceDelegation;

public class Foo
{
    public void Bar() { }

    public void Baz(int value) { }
    
    internal int Qux => 42;
}

public partial class Qux
{
    [Lift(
        filter: new[] { "Bar", "Qux" }, // Bar, Qux만 위임
        remove: new[] { "Bar" }, // Bar를 제외
        rename: new[] { "Qux:Quux" } // Qux를 Quux로 변경
    )]
    private Foo _foo = new();
}
```

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Qux
{
    #region global::Foo
    internal int Quux
    {
        get => _foo.Qux;
    }
    #endregion
}
```
